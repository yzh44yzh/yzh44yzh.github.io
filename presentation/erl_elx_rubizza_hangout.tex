\documentclass[10pt]{beamer}
\usepackage{fontspec}
\usepackage{listings}

\setmainfont{Ubuntu}[]
\setsansfont{Ubuntu}[]
\setmonofont{Ubuntu Mono}[]

\usetheme{Singapore}
\usecolortheme{dove}
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{headline}{}

\lstset{
  language=ML,
  keywordstyle=\color{blue},
  backgroundcolor=\color{lightgray}
}

\title{Эрланг и Эликсир \\
  \large Зачем они вообще нужны? \\
  И зачем они нужны лично вам?}
\author{Юра Жлоба}
\institute{Wargaming.net}
\date{Ноябрь 2019}

\begin{document}
\maketitle

\section{История}

\begin{frame}
\frametitle{Чуть-чуть истории}
\centering
Это важно для понимания сути.
\end{frame}

\begin{frame}
\frametitle{Агнер Краруп Эрланг}
\centering
Датский математик, статистик и инженер,
\par \bigskip
автор "Теории массового обслуживания".
\end{frame}

\begin{frame}
\frametitle{Теория массового обслуживания}
\centering
1909
\par \bigskip
Теория очередей, Queueing theory
\par \bigskip
Математическая модель для оценки пропускной способности телекоммуникационных сетей
\end{frame}

\begin{frame}
\frametitle{Теория массового обслуживания}
\begin{itemize}
\item не только сетей, но и
\item дорог (автомобильных, железнодорожных и т.д.)
\item больниц
\item складов, магазинов
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Эрланг, это}
\begin{itemize}
\item датский ученый
\item единица пропускной способности сети
\item язык программирования
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{highload 80-х}
\centering
Эрикссон (Ericsson)
\par \bigskip
телекомуникационное оборудование и услуги.
\end{frame}

\begin{frame}
\frametitle{highload 80-х}
\begin{itemize}
\item сложное оборудование
\item сложный софт
\item большой траффик
\item жесткие требования по доступности сервиса
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Совсем краткая история}
\begin{itemize}
\item 80-е -- разработка языка
\item 90-е -- использование внутри компании Эрикссон
\item 2000-е -- выход в мир
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{2007 год, закон Мура больше не работает}
\centering
Предел наращивания частот процессоров.
\par \bigskip
Рост количества процессоров и их ядер.
\par \bigskip
Необходимость в разработке многопоточных программ.
\end{frame}

\begin{frame}
\frametitle{2007 год, закон Мура больше не работает}
\centering
Рост интереса к ФП.
\par \bigskip
Копирование идей ФП в мейнстримовые языки.
\end{frame}

\begin{frame}
\frametitle{2011 год, появление Эликсир}
\centering
Жозе Валим (José Valim)
\par \bigskip
Один из основных разработчиков Ruby on Rails.
\end{frame}

\iffalse

\section{Вирутальная машина}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

Все клевые фишки.

Важные особенности Эрланг

Изначально, еще до разработки эрланг, были сформулированы требования к языку:
- Concurrency -- эффективная реализация многопоточности
- Fault Tolerance -- устойчивость к программным и аппаратным сбоям
- Distribution -- поддержка распределенных систем
- Hot Code Upgrade -- возможность горячего обновления кода

К этим 4-м столпам, описанным во всех книгах по эрланг, я добавлю еще несколько фич:
- Symmetric Multiprocessing
- Actor Model
- Soft Real Time
- Garbage Collection
- Erlang Shell
- Tracing

Сердцем Erlang является Erlang Run-Time System (ERTS) -- виртуальная машина, которая выполняет байт-код эрланг.
Реализована на С, и все описанные ниже фичи обеспечиваются ей.


Concurrency

Процессы являются базовой сущностью языка.

Процессы легковесны, их можно создавать десятки и сотни тысяч. Переключение между ними очень быстрое.

Нет разделяемой области памяти, каждый процесс имеет свою изолированную память.

Ошибки в процессах также изолированы, падение одного процесса не влияет на работу остальных.

Данные между процессами передаются путем "отправки сообщений" (message passing).
При этом данные копируются из памяти одного процесса в память другого.

1024 - 134,217,727 (2^10 - 2^27)
дефолтное значение 262,144 (2^18)

Запуск нового процесса - 3-5 микросекунд.

На старте поток занимает 2696 байт, включая стек, кучу и память под свои метаданные
(потом резервирует больше памяти, если нужно).

Запускается несколько планировщиков, соответственно количеству процессорных ядер.
Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские процессы.

Планировщики умеют балансировать нагрузку, перераспределяя потоки между собой.
У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров,
но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.

Lukas Larsson - Understanding the Erlang Scheduler
https://www.youtube.com/watch?v=tBAM_N9qPno


Fault Tolerance

Большинство языков для этого предлагает механизм исключений. И
разработчик может получить относительно безопасный код, если правильно
расставит try…catch и правильно обработает ошибки.

В Erlang это тоже есть, но это только первый уровень изоляции
ошибок. И он довольно редко используется, из-за того, что другие
уровни работают хорошо. Если вы возьмете исходники какого-нибудь
крупного известного эрланг проекта, например, Cowboy или Riak, и
поищите там try..catch, то найдете их очень мало.

Вторым уровнем является дерево супервизоров. В Erlang есть специальные
потоки, которые сами не выполняют полезной работы, а наблюдают за
другими. Такие специальные потоки называются supervisor
(наблюдатели). Ну а потоки, которые выполняют реальную работу,
называются worker (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно
завершается. Супервизор получает об этом сообщение, и может принять
какие-то меры. Стандартная мера – логировать ошибку и перезапустить
рабочий поток заново. При этом мы имеем потери -- текущее состояние
памяти потока, но можем продолжать работу.

Супервизоры наблюдают не только за рабочими процессами, но и друг за
другом. Для этого все потоки организованы в дерево, где узлами
являются супервизоры, а листьями – рабочие потоки.  В более сложной
ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И,
наконец, все дерево целиком.

Третий уровень изоляции ошибок – объединение узлов в кластер. Если узел
все-таки падает, или вообще сервер выходит из строя из-за проблем с
железом, то его функцию может взять на себя резервный узел.


Distribution

A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.
Leslie Lamport.

Устойчивость в т.ч. и к аппаратным авариям является одним из требований к эрланг.
И обеспечить эту устойчивость можно только в распределенной системе.

Железо выходит из строя не так часто, но это случается.
Если инфраструктура состоит из сотен серверов, то это случается регулярно, и является штатной ситуацией.

2 цели:
- горизонтальное масштабирование
- устойчивость к авариям

Сетевая прозрачность (location transparency)

Процессы общаются отправкой сообщений друг другу, при этом не важно,
находятся ли они на одном узле, или на разных.

За реализацию отвечает виртуальная машина. Она сама открывает сокеты,
устанавливает нужные TCP соединения между узлами, мониторит их
состояние – программисту об этих низкоуровневых вещах думать не нужно.

Сетевая прозрачность касается не только отправки сообщений, но и мониторинга процессов.
Supervisor может запускать и мониторить worker на другом узле.

эрланг-узлы, собранные в кластер, формируют доверенную среду (trusted environment).
Нет ограничения прав. Любой процесс может посылать любые сообщения кому угодно.
Это удобно, но не безопасно.
Подразумевается, что все узлы находятся в одной локальной сети,
и сеть защищена от внешнего мира.


Hot Code Upgrade

Эрланг позволяет загрузить в рантайм новую версию кода модуля,
и переключить выполнение процесса со старой версии на новую,
сохранив состояние его памяти.

Если в коде изменились структуры данных,
то есть способ мигрировать данные из старой структуры в новую.

Еще может измениться дерево супервизоров, и нужно стартовать новые процессы,
или завершать старые.

Эти проблемы так или иначе решаются.


Symmetric Multiprocessing

С 2006 года одна эрланг умеет эффективно использовать все процессорные ядра в системе,
и перераспределять нагрузку между ними.

То есть, процесс, запущенный под одним планировщиком, на одном процессорном ядре, может быть
передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре.

Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, его запускали
на чипах с 1024 ядрами, и эрланг эффективно использовал ресурс всех этих ядер.

Erlang Scheduler Details and Why It Matters
https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html


Actor Model

https://en.wikipedia.org/wiki/Actor_model

Один из способов реализации многопоточности.

Система состоит из акторов, которые действуют паралельно и независимо друг от друга.

Акторы общаются друг с другом с помощью отправки сообщений (message passing).
Один поток может послать другому любые данные.
При этом данные копируются, и получающий поток никак не может повлиять на данные отправителя.

Отправка сообщений является асинхронной.
При необходимости можно реализовать синхронный вызов -- блокировать процесс на какое-то время, и ждать, пока придет ответное сообщение.

Каждый актор имеет mailbox, где накапливаются полученные им сообщения.
Это специальная область памяти процесса.
Процесс проверяет свой mailbox, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека.
Например, библиотека Akka http://akka.io/ для Scala и Java.

Но в эрланг эта модель реализована в виртуальной машине и поддерживается непосредственно на уровне языка.


Soft Real Time

https://en.wikipedia.org/wiki/Real-time_computing

На эрланг можно строить системы реального времени -- то есть, системы, где требуется предсказуемое время ответа.

Это возможно благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- настраиваемому IO;
- особенностям сборки мусора (garbage collection).

Да, планировщики в эрланг реализуют вытесняющую многозадачность.

IO не выполняется в каждом процессе отдельно, а выполняется через специализированный пул процессов,
и его можно тонко настраивать.

Про сборку мусора поговорим отдельно.


Garbage Collection

Сборка мусора в функциональных языках несколько проще, чем в
императивных, благодаря неизменяемым переменным.  Из-за этого точно
известно, что переменные, созданные раньше, не могут указывать на
объекты, созданные позже.

Сборщик мусора в Erlang делит объекты на два поколения: молодые и
старые. И исходит из предположения, что большинство молодых объектов
являются короткоживущими, и для них память нужно чистить чаще. А
большинство старых объектов являются долгоживущими, и для них память
можно чистить реже.

В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

А вот что в эрланг особенного, это отдельный сборщик мусора для каждого процесса.
В Erlang все сборщики работают независимо друг от друга, в разные моменты времени, и останавливают только свой процесс.
И отсюда отсутствие эффекта stop world, когда сборщик мусора должен остановить всю ноду для своей работы.

Если поток короткоживущий (что довольно обычно для Erlang),
то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи),
то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.

Erlang Garbage Collection Details and Why It Matters
https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html


Erlang Shell

Как и многие другие языки, эрланг имеет REPL консоль.
Ей удобно пользоваться при разработке.

Но ей можно пользоваться и в продакшен. Можно подключиться к работающей ноде,
вызывать любую функцию любого модуля, отправить сообщение любому процессу,
прочитать и изменить состояние любого процесса -- то есть,
взаимодействовать с нодой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их налету.


Tracing

В эрланг есть встроенный на самом низком уровне механизм трассировки,
мало влияющий на общую производительность системы. Поэтому его можно
использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- жизненный цикл процессов (старт, остановка, связи с другими процессами);
- отправка и получение сообщений;
- вызовы функций, аргументы, возвращаемые значения, откуда вызвана;
- наблюдать состояние процессов, и менять его;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе ноды. Практически этой
информации очень много, и сложность в том, чтобы выбрать именно ту, которая важна.

Данные трассировки можно наблюдать в консоли, или перенаправить в
файл, или в свой обработчик. Ее можно получать на той же ноде, или
перенаправить на другую ноду, и обрабатывать и анализировать там.


Какие есть языки.


\section{Эрланг}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

Язык водопроводчиков. Трубы и бассейны. Школьные задачи: по одной трубе затекает, по другой вытекает.
Очереди и хранилища данных.
RabbitMQ & Riak
Задача -- доставить, преобразовать, сохранить данные.
Проблемы: недоиспользование ресурсов, нехватка ресурсов. Нередко обе проблемы одновременно.

Основные фишки

Области применения

много долгих сессий
распределенные системы

Самая подходящая сфера применения для эрланг, это сервер, обслуживающий много *долгоживущих* соединений.

Обслуживать много соединений умеют многие. Если это короткие соединения, как, например, HTTP-запрос.
Но все становится сложнее, если эти соединения долгоживущие. На эрланг такую задачу решать проще.

Классический пример таких серверов -- это Instant Messaging и многопользовательский чат.
Не зря история не-эрикссоновского эрланга началась с ejabberd.
Facebook chat начинался с эрланг (сейчас там Scala).

И, конечно, нашумевшая история WhatsUp https://habrahabr.ru/post/276951/

19 февраля 2014 года Facebook купил WhatsApp за 19 млрд долл.

Некоторая статистика WhatsApp:
2014/2018 год.
monthly users:  465M -> 1.5B  x3
daily messages:  19B ->  60B  x3
daily pics:     600M -> 4.5B  x7
daily videos:   100M ->   1B  x10

Не редко эрланг является основным или, как минимум, важным компонентом Cloud Platform.
В этой роли его используют Amazon, Yahoo, Heroku, Github.

Для многих (в т.ч. для Wargaming) знакомство с эрланг начинается с RabbitMQ.
Полезный инструмент, мы в Wargaming используем его очень широко.

Распределенные базы данных: Riak, CouchDB.


Применение в вебе

Первое поколение:
Веб сервера: YAWS, Mochiweb
Фреймворки: Chicago Boss, Nitrogen, N2O

Второе поколение:
Веб сервер: Cowboy
Фреймворки: нет

Почему нет фреймворков? Во-первых, оказалось, что на эрланг трудно сделать что-то похожее на Ruby on Rails или Django.
Во-вторых, появился Elixir.

Бэкенд сервисы, которые непосредственно с пользователем не работают, UI для него не генерируют,
но предоставляют API для клиентских компонентов. Это может быть HTTP API, или не HTTP.
Клиентом может быть JS-приложение в браузере, или мобильное приложение, или другой бэкенд сервис.

Те, кому нужен такой веб, как Ruby on Rails или Django, направили усилия на Elixir / Phoenix.

Третье поколение:
Elixir/Phoenix
и за ним будущее.


Недостатки

Главный недостаток любого не мейнстримового языка -- малое количество разработчиков.
Для компании, которая решится использовать эрланг в своем бизнесе, это серьезный риск.
Фейсбук именно поэтому отказался от эрланг.

Из-за малого количества компаний мало вариантов для разработчиков.
Для разработчика инвестировать много времени и глубоко изучить язык -- тоже риск.
Лучше сохранять компетенцию в других, более популярных языках, чтобы иметь больше вариантов трудоустройства.

Порочный круг: нет компаний, потому что нет разработчиков. Нет разработчиков, потому что нет компаний.
Круг разрывается за счет энтузиастов (обычно разработчиков), которые вкладывают свои усилия,
не рассчитывая, что это оправдается коммерчески.

Не так много библиотек, как в мейнстрим языках. И имеющиеся библиотеки обычно не достигают того уровня зрелости и стабильности,
к которому привык, например, Java-разработчик.

Динамическая типизация. Тут вопрос, конечно, спорный. Но лично я бы предпочел статическую типизацию.
dialyzer есть, но он необязательный, и с ним есть свои нюансы. Все-таки, это штука приделанная сбоку,
а не естественная часть языка.

Язык консервативный и не модный. При этом он развивается довольно быстро. Но это больше касается виртуальной машины,
чем фич самого языка. То есть, развивается он не путем добавления новых фич, а путем шлифовки того, что уже есть.
Лично мне это нравится.

Для веб-разработчиков, привыкших к Ruby on Rails, эрланг и его инфраструктура (библиотеки, инструменты)
слишком бедный, и слишком низкоуровневый.


\section{Эликсир}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

Основные фишки
См предисловие Жозе Валима к книге Дейва Томаса. Там хорошо объяснено.

Области применения

Phoenix, web with frontent/UI
(На эрланге такое не делают, попытки сделать фреймворк типа Django/Rail были, но не успешные. Язык недостаточно гибкий.)


\section{Разбор мнений/мифов}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

\begin{frame}
\frametitle{}
\centering
\par \bigskip
\end{frame}

*** Рубисту просто начать писать на Elixir'e, так как синтаксис очень похож.

Ну синтаксис может быть местами и похож. Была такая идея на ранних этапах развития Эликсир, сделать его похожим по синтаксису на Руби. Потом от этого отказались.

Дело в том, что сам по себе синтаксис не важен, важна семантика. А семантика у Эликсир совсем другая, чем у Руби.

В основе эликсир две ключевые вещи: функциональная парадигма программирования, и акторная модель многопоточности.
Их нужно будет понять и принять, и синтаксис тут ничем не поможет.

Что касается легкости изучения, то из моего опыта (я обучаю эрлангу уже давно, эликсиру пока еще нет, готовлюсь) бывают разные ситуации.
Если человек уже знаком с ФП, то проблем не возникает.
Если не знаком, то как повезет. Кто-то с ходу все схватывает, и тут же пишет правильный код. Кому-то никак не заходит, и он сдается.

Нормально работает вариант, когда в команде есть 1-2 эксперта, а остальные переучились на ЭЭ с других языков.
Вариант, когда экспертов нет, а есть только переученые люди с опытом в других языках -- слишком рискованый, я не рекомендую.


*** Elixir хорошо масштабируется

"Если пишешь приложение на Elixir'e, то DevOps не нужен. Будет и так хорошо работать и масштабироваться. Нужно просто инстансов больше закидывать."

Это правда, что на Эликсир легко писать проекты, которые хорошо масштабируются.

Но если вы ждете, что масштабирование работает само по себе из коробки, и думать ни о чем не надо, но это неправда.

Масштабирование -- архитектурная проблема, и она ортогональна языку программирования. Язык можно использовать любой. А думать нужно, много, о разном.
(Шардирование, батчинг, репликация, кэши, консистентность данных и т.д.)

Чем отличается ЭЭ, это тем, что накоплено 40 лет опыта масштабирования таких систем, есть инструменты, описаны подходы.


*** Эликсир хорош для работы с WebSocket

Чистая правда. В более широком смысле ЭЭ хорош для проектов, где нужно держать одновременно много долгоживущих соединений.

И это такая ниша, где у ЭЭ мало конкурентов.


*** Elixir решает проблемы многопоточности

Да. Об этом много сказано выше.


*** Elixir есть Erlang VM и он хорошо работает на распределенных системах

Да, но см выше все сказанное про масштабирование.


*** Elixir работает быстрее чем Ruby

Ох, какая большая тема для обсуждения!

Это правда. Сферическая скорость в вакууме для ЭЭ будет больше, чем для питона и руби, но медленнее жава и го.
Пожалуй, и не только сферическая, и а в большинстве прикладных случаев тоже.
Но дело в том, это не так важно, как принято считать.
И идея и архитектура Эрланговской виртуальной машины, она не про скорость. Она про максимально эффективное использование ресурсов.

У нас как-то принято много обсуждать производительсность.
Часто можно видеть обсуждения, что вот такая конструкция языка работает быстрее, чем эдакая. И этому посвящают немало времени.
На самом деле вот эта вот производительность на уровне алгоритмов и структур данных переоценена.

Да, для бизнеса важна производительность. Но обычно проблемы производительности, важные для бизнеса, решаются на уровне архитектуры.
Да, есть отдельные области, где нужно выжать максимум из тактов процессора, байтов памяти и пропускной способности сети:
- микроконтроллеры и другое маломощное встраиваемое железо
- биржевая торговля
- база данных

Но гораздо чаще нас интересует масштабирумость системы, а не экономия железа.
Железо стоит дешевле, чем время программистов. А вот если сервис не масштабируется, тогда это проблема, которую нужно решать, и ЭЭ решают ее неплохо.

Но если вам действительно нужно экономить железо, то для ЭЭ есть некоторые подходы.

Правда в некоторых комментариях я видел, что речь идет не о скорости абстрактной в вакууме,
а конкретно о латерси в ответах на HTTP-запросы, которая для Руби высокая и не оптимизируется.
Если так, то это не достоинство Эликсир, а недостаток конкретно Руби.
В Питоне, например, такой проблемы нет. На питоне делают веб-сервисы с коротким латенси.

Обычно проблемы латенси HTTP-сервиса сводятся к проблемам латенси запросов в БД.
И это либо уровень приложения (ORM генерирует неэффективные запросы, либо выполняет больше запросов чем нужно),
либо уровень самой БД.

Ecto -- явное разделение генерации запроса и выполнения запроса. Можно выполнять сырой SQL.

Erlang -- ORM нету (попытки были), но он и не нужен.
В эрланг проектах обычно схема данных не сложная, 5-10 таблиц, 10-20 вариантов запросов к ним, и все.
SQL пишется вручную, и это не доставляет проблем.

Сложность растет не в сторону 100 сущностей, 50 связей между ними, а в сторону шардирования таблиц.

Схема WGNC: email_notification, 32 шарда, дневные партиции. Запросы в конкретную партицию. ORM в таких делах не помогает.
В эликсировских проектах Ecto не расчитана на шардирование, и тут есть сложности, которые нужно решать отдельно.

А есть еще конфликт latency vs throuput. И тут тоже есть о чем поговорить.



*** Эликсирщикам больше платят

Тут трудно сказать. Вероятно, зависит от локации, и многих других факторов.

Но из общих соображений можно сказать следущее:
- Эксперт с редкой специализацией часто стоит дороже, чем эксперт с широко распространенной специализацией.
- Чем более сложные системы создаются, тем более квалицифированные и дорогие инженеры нужны.

Я не хочу сказать, что на ЭЭ пишут более сложные системы, чем на Руби. Но там решают другие задачи, и требуется другой опыт.

Но тут есть два НО:
- Эксперт с профильным опытом.
- Редкая специализация нужна не многим компаниям, поэтому могут быть трудности с поиском работы.

Трудности в обе стороны: компании трудно найти инженера, инженеру трудно найти компанию.

Такой ситуации, когда вообще нет вариантов работы, может и не будет. Но вот выбор вариантов будет гораздо уже.

Хорошо быть экспертом и широкого профиля, и узкого одновременно :) Хватило бы жизни, чтобы таким стать :)


*** Zero downtime. With Elixir, you can reach 100% up-time without having to stop for updates.
You can deliver the updates to the production without interfering with its performance.

Это есть, но на практике этим никто не пользуется. Довльно сложно. Обычно обходятся коротким downtime.
А если есть требование zero downtime, то его все равно нужно решать на уровне кластера: кластер должен уметь переживать падение и возвращение ноды.
И если он умеет, то не проблема рестартовать ноды по очереди при обновлении.


*** Учить эликсир можно ж и не ради того чтобы писать на нем в продакшн.
Имо, основная ценность изучения эликсира рубисту - посмотреть как задизайнен OTP и как устроен Phoenix.
Если написать даже простейший бложик на фениксе, то есть шанс, что рейлс головного мозга отомрет быстрее и будет больше мотивации потрогать какой-нибудь Hanami.

Соглашусь. Изучать разные ЯП и разные подходы к программированию полезно для расширения кругозора.

На мой взгляд хороший инженер должен иметь 2-3 ЯП в своем арсенале, и уметь выбирать подходящий для конкретного проекта.
В варгейминге именно это и практикуется.


*** Elixir is the first programming language after Ruby that considers code aesthetics and language UX. It also cares about the libraries and the whole ecosystem.
Стоит ли это брать в доклад? наверное не стоит.

О, про это я бы хотел сказать отдельно :) На мой взгляд, многие вещи в Эликсир сделаны коряво.

И они таким получились не потому, что авторы это планировали, а случайно.
Вообще дизайн языка сформировался во многом случайно, а не по плану.
Это легко заметить, если сравнивать одни и те же языковые конструкции в Эликсир и в родственных (по семантике) языках: Haskell, OCaml, F#.

Примеры косяков в дизайне языка:
- точка при вызове анонимной функции
- неудавшаяся попытка реализовать без-скобочный синтаксис вызова функции
- конструкция with, где первое выражение обязательно должно быть на той же строке, что и with
- три вида исключений и много вариантов их обработки. (Слава богу, ни один из них почти никогда не нужен).
- pipe-оператор подставляет первый аргумент, а не последний, как во всех других ML-языках. (Это из-за отсутствия каррирования).

А вот библиотеки, документаци и вся экосистема -- да, отличные. Особенно на фоне Эрланга, где все гораздо беднее.

\fi

\begin{frame}
\centering
Вопросы?
\end{frame}

\end{document}
