* gen_server -- сервер внутри сервера

Доклад для 1-й встречи Belarus Erlang User Group

21 июня 2014

*[[http://www.erlang.org/doc/man/gen_server.html][gen_server]]* хорошо известный и активно используемый паттерн.
С другой стороны, он требует некоторых усилий для понимания.

Хороший подход к изучению gen_server -- написать его самому.
Такой подход выбрал и Joe Armstrong ([[http://pragprog.com/book/jaerlang2/programming-erlang][Programming Erlang, глава 16]]), и
Fred Hebert ([[http://learnyousomeerlang.com/what-is-otp#its-the-open-telecom-platform][LYSE, глава What is OTP?]]).

Способ эффективный, но я в своем докладе не буду его повторять.
Вы, наверняка, это читали. Ну а если не читали, то прочитаете :)
Я лучше покопаюсь во внутренностях gen_server и расскажу о некоторых
нюансах его использования.


* внутренности gen_server

Ну и с места в карьер, посмотрим, как выполняется инициализация gen_server.

** gen_server:start_link(...)

/img/gen_server/gen_server_init.png

На этой схеме и последующих:
 -  Левые квадраты, верхний и нижний -- это callback-модуль, написанный программистом.
 -  Правые квадраты, верхний и нижний -- это код OTP фреймворка (модули gen_server, gen, proc_lib).
 -  Верхние квадраты, правый и левый -- это код, который выполняется в потоке клиента.
 -  Нижние квадраты, правый и левый -- это код, который выполняется в потоке сервера.

Начинаем отсюда:

#+BEGIN_SRC Erlang
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
#+END_SRC

Далее вызывается *gen:do_spawn(...)*,
где берется Timeout из Options если он там есть, иначе по дефолту задается infinity
и вызывается *proc_lib:start_link(...)*.

Дальше вызывается *proc_lib:spawn_opt(...)*
где определяется родительский процесс и все его предки,
вызывается *erlang:spawn_opt(...)*, который и создает новый серверный процесс.
После чего клиентский процесс вызывает *sync_wait(...)*,
блокируется в *receive* с заданным timeout и ждет сообщение *ack* от сервереного процесса.

Серверный процесс либо пришлет подтверждение, что он создан и у него все ок *{ack, Pid, Return}*,
либо упадет при инициализации *{'EXIT', Pid, Reason}*, либо ничего не придет до истечения timeout.
В последнем случае серверный процесс убивается, и возвращается ошибка.

Тем временем жизнь серверного процесса начинается с *gen_server:init_it(...)*.
Здесь настраиваются параменты отладки из агрумента *Options*, если есть,
и от *sys:debug_options(...)*.

Затем вызывается *init* нашего callback-модуля, где мы вольны инициализировать сервеный
процесс как нам угодно. Например, может создать для него структуру данных, хранящее состояние
и вернуть ее *{ok, State}*.

Дальше посылается подтверждение клиентскому процессу *proc_lib:init_ack(...)*.
И, наконец, серверный процесс входит в основной цикл *gen_server:loop(...)*.


** gen_server:call(...)

/img/gen_server/gen_server_call.png

Начинаем отсюда:

#+BEGIN_SRC Erlang
get_staff() ->
    gen_server:call(?MODULE, get_staff).

gen_server:call(Name, Request) ->
    case catch gen:call(Name, '$gen_call', Request) of
        {ok, Res} -> Res;
        {'EXIT', Reason} -> exit({Reason, {?MODULE, call, [Name, Request]}})
    end.
#+END_SRC

*gen:call(...)* разбирается, что такое *Name* -- процесс, или список узлов;
и разбрается с Timeout. В отличие от *gen_server:start_link* здесь timeout по
умолчанию будет 5 секунд.

Затем *gen:do_call(...)* делает основную работу:
 - устанавливает монитор на серверный процесс, который заодно служит уникальным
   идентификатором сообщения;
 - посылает сообщение серверному процессу *{'$gen_call', {self(), Mref}, Request}*;
 - блокируется в *receive*, ожидая ответного сообщения;
 - ответ матчится по *Mref* монитора;
 - при получении ответа монитор снимается, ответ возвращается клиенту;
 - обрабатывается падение серверного процесса, возвращается ошибка;
 - обрабатывается timeout, возвращается ошибка.

Здесь же обрабатывается и *gen_server:multi_call(...)* на удаленные узлы, так что код сложнее.

Между тем, серверный процесс, находясь в *gen_server:loop(...)* ждет сообщение. Ловит все подряд,
обрабатывает в *gen_server:decode_msg(...)*.

Могут приходить системные сообщения *{system, From, Req}*,
они передаются для обработки в *sys:handle_system_msg(...)*. Это могут быть
сообщения *shutdown* от супервайзера, запросы на получение и замену состояния
серверного процесса, используемые при отладке.

Если включена отладка, то входящие сообщения передаются в *sys:handle_debug(...)*.
Затем передаются дальше в *gen_server:handle_msg(...)*, где
отдельный клоз матчится на *{'$gen_call', From, Msg}*. Тут, наконец, вызывается
*handle_call* нашего модуля, обрабатываются все варианты ответов и ошибки,
после чего ответ посылается сообщением клиентскому процессу, а серверный
опять входит в *gen_server:loop(...)*.

Если включена отладка, то исходящие сообщения тоже передаются в *sys:handle_debug(...)*.


** gen_server:cast(...)

/img/gen_server/gen_server_cast.png

Ну тут ответ не нужен, так что все проще.

Начало аналогичное:

#+BEGIN_SRC Erlang
add_staff(Staff) ->
    gen_server:cast(?MODULE, {add_staff, Staff}).

gen_server:cast(Name, Request) ->
    case catch gen:call(Name, '$gen_cast', Request) of
        {ok, Res} -> Res;
        {'EXIT', Reason} -> exit({Reason, {?MODULE, call, [Name, Request]}})
    end.
#+END_SRC

Дальше тот же путь через *gen_call(...)*, *gen:do_call(...)*, *gen_server:loop(...)*,
*gen_server:decode_msg(...)* и, наконец, *gen_server:handle_msg(...)*, но другой клоз,
откуда сообщение передается на *gen_server:dispatch(...)*. И тут для сообщений
*{'$gen_cast', Msg}* вызывается *handle_cast*, для всех остальных *handle_info*
нашего модуля.


** Нюансы

Это было в общих чертах. Дальше всякие нюансы :)


*** start_link

Для старта *gen_server* есть 4 функции *start/3*, *start/4*, *start_link/3*, *start_link/4*.
Сперва о разнице между *start* и *start_link*. Второй вариант создает связь между родительским
процессом и серверным. Первый вариант такой связи не создает. Второй вариант всегда должен
использоваться в реальном коде, чтобы супервизор мог мониторить своих потомков. Первый
вариант можно использовать в консоли, чтобы запускать разрабатываемый модуль для отладки.

C аргументами, я полагаю, все должно быть понятно, дублировать документацию не буду :)
Единственное, чтобы понять последний аргумент *Options*, нужно читать документацию по
[[http://www.erlang.org/doc/man/erlang.html#spawn_opt-4][erlang:spawn_otp]]. Там настройки работы с памятью и приоритета процесса.
Впрочем, это чаще всего не нужно трогать.


*** init

*init* блокирует родительский процесс, причем с timeout = infinity по умолчанию. Желательно
оставлять эту функцию легковесной, и возвращать управление родителю как можно быстрее.

Если инициализация сервера требует долгих действий (чтение файлов, установку соединения с базой и т.д.),
то такие вещи лучше делать отложено.

Отложенную инициализацию можно сделать двумя способами:

Послать самому себе сообщение, поймать его в handle_info, и сделать тяжелую инициализацию там.

#+BEGIN_SRC Erlang
init(Args) ->
    State = ...
    self() ! heavy_init,
    {ok, State}.

handle_info(heavy_init, State) ->
    NewState = ...
    {noreply, NewState};
#+END_SRC

Или задать timeout = 0 в ответе *init* и в *handle_info* обработать сообщение *timeout*

#+BEGIN_SRC Erlang
init(Args) ->
    State = ...
    {ok, State, 0}.

handle_info(timeout, State) ->
    NewState = ...
    {noreply, NewState};
#+END_SRC


Про изначальный смыл {ok, State, Timeout} будет ниже.

А еще очень нежелательно в *init* крашится :) Такой краш обычно проявляется на старте приложения,
а старт приложения обычно происходит на старте узла. Так что при этом весь узел падает, и с не
очень понятными сообщениями в логе.


*** handle_call

TODO

8 вариантов ответа :)
3 reply (обычный, с timeout, hibernate)
3 noreply (обычный, с timeout, hibernate)
2 stop (с Reply и без Reply)

варианты noreply и вариант stop без Reply требуют
gen_server:reply/2, From = {Pid, Ref}
иначе вызов gen_server:call завершится без ответа по timeout

если мы хотим ответить быстро, а сообщение будем обрабатывать долго, и потому нужно ответить
после получения сообщения, но до его обработки


*** handle_cast
4 варианта ответа
3 noreply (обычный, с timeout, hibernate)
stop


*** handle_info
если мы мониторим что-то, то будем получать EXIT сигналы

те же 4 варианта ответа


*** terminate
если был ответ stop в одном из handle_*

нормальные причины: normal, shutdown, {shutdown, Term}
все другие OTP рассматривает как ошибку и логирует

shutdown -- если gen_server останавливается из-за остановки своего супервизора
и у него стоит флаг trap exit
и shutdown стратегия супервизона не brutal_kill.


*** code_change
Это надо рассматривать в теме релизов. Пропускаю.


*** format_status
Имеет дефолтную реализацию, используется для формирования сообщения об ошибке при падении процесса.
crash report
Можно сделать свою реализацию, если хочется показать State как-то более информативно.


** gen_server, поток клиента
Basic Abstraction Libraries: sys, proc_lib
stdlib app

http://www.erlang.org/doc/man/sys.html
A Functional Interface to System Messages
The sys module can be used for debugging a gen_server.

TODO: попробовать все это
9> sys:statistics(code_lock, false).
10> sys:trace(code_lock, false).
11> sys:get_status(code_lock).

http://www.erlang.org/doc/man/proc_lib.html
Functions for asynchronous and synchronous start of processes adhering to the OTP design principles.

При старте процесса запоминает инфу: pid, зарегистрированное имя, все
родительские процессы, начальная функция. При падении процесса инфа используется
для формирования crash report.
Позволяет задать ряд настроек: приоритет, heap size, сборка мусора.
К нормальным причинам завершения процесса добавляет shutdown, {shutdown, Term}

gen_server:enter_loop


** gen_server, поток сервера
loop, state


* timeout и hibernate
init, handle_call, handle_cast, handle_info могут вернуть Timeout или hibernate

{ok, State, hibernate}
отбрасывает стек, проводит сборку мусора, дефрагментирует heap
в итоге процесс занимает меньше памяти
имеет смысл, если процесс редко получает сообщения,
и много времени проводит ничего не делая, в ожидании

А в чем изначальный смысл этого {ok, State, Timeout}?
If an integer timeout value is provided, a timeout will occur unless a
request or a message is received within Timeout milliseconds.
Видимо, чтобы обрабатывать ситуацию, когда долго не приходят сообщения.
Можно в hibernate уйти по этому поводу.


* отладка с помощью модуля sys
http://www.erlang.org/doc/design_principles/spec_proc.html
http://www.erlang.org/doc/man/sys.html


* что в gen_server можно сократить?
TODO
наверняка есть какой-то overhead, который можно убрать, и что-то выйграть

TODO

Loïc Hoguin

Founder of the Nine Nines open source Erlang company. Main author of the Cowboy, Bullet, Sheriff and Farwest projects. Spawnfest co-founder and organizer.

Beyond OTP
http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/LoicHoguin

они в cowboy заменили gen_server, выйграли на чем-то 20% производительности
TODO найти этот момент на видео доклада, посмотреть
TODO посмотреть, где в ковбое proc_lib, и за счет чего они там выйграли

Если вы хоже хотите что-то выжать по производительности, и для этого
сделать свою реализацию вместо gen_server, gen_fsm, gen_event и т.д.
но так, чтобы она была полноценным участником OTP приложения,
читайте доку:
http://www.erlang.org/doc/design_principles/spec_proc.html

Там не так уж и сложно. Все толково описано, и есть хороший пример реализации.

be started in a way that makes the process fit into a supervision tree,
support the sys debug facilities, and
take care of system messages.

proc_lib для старта процесса

исползовать sys для отладки

System messages are messages with special meaning, used in the
supervision tree. Typical system messages are requests for trace
output, and requests to suspend or resume process execution (used
during release handling). Processes implemented using standard
behaviours automatically understand these messages.

* Нюансы использования

Для все handle_ последний клоз должен быть catch-all, пишуший в логи ошибку
TODO иначе процесс упадет с badmatch? Проверить. Должен падать.

Из презентации Лебедевича:
- не падать в init :), такие падения не дают стартовать приложению и сложны в отладке (непонятный лог)
  TODO: воспроизвести ситуацию, дать пример такого лога
- timeout = infinity, трудно диагносцируемый deadlock,
  лучше ставить конкретное число, тогда deadlock себя проявит
  ну или не указывать, пусть будут дефолтные 5 сек

handle_* должны иметь последний клоз catch all и логировать все неизвестные запросы как ошибку

gen_server и dialyzer, написание spec для handle_*

отправка сообщений и handle_info работают быстрее, чем gen_server:call/cast
если мы жутко все оптимизируем и экономим на спичках, можно попробовать это.

If it is necessary to clean up before termination, the shutdown
strategy must be a timeout value and the gen_server must be set to
trap exit signals in the init function. When ordered to shutdown, the
gen_server will then call the callback function terminate(shutdown,
State):
init(Args) ->
    ...,
    process_flag(trap_exit, true),
    ...,
    {ok, State}.

...

terminate(shutdown, State) ->
    ..code for cleaning up here..
    ok.
