* Паттерны взаимодействия процессов

Рассмотрим такую базовую ситуацию в Erlang/Elixir, когда у нас есть некий процесс (worker_1), и ему нужно как-то взаимодействовать с другим процессом (worker_2). Так ли проста эта ситуация? Не смотря на то, что это очень базовая ситуация, она не очень проста.

Во-первых, worker_1 каким-то образом должен узнать Pid worker_2. Во-вторых, worker_2 в нужный момент может не существовать (еще не создан, или уже завершился). В-третьих, worker_2 может быть рестартован, и тогда Pid у него поменяется.

Как с этим жить? Я постараюсь рассмотреть несколько вариантов, описать плюсы/минусы, и подходящие варианты применения для каждого.

Начнем с того, что у каждого процесса есть жизненный цикл: start, run, hibernate, stop, restart. И этим жизненным циклом кто-то должен управлять. Обычно этот кто-то -- это супервизор. Кроме этого есть правило, что все процессы так или иначе должны быть слинкованы в supervisor tree.

Если вы начинающий Erlang/Elixir разрабочик, то вам важно придерживаться подходов OTP. Если вы опытный разработчик, то можете себе позволить где-то нарушить правила и срезать углы :) Но тут важно понимать, что вы делаете.

TODO: описать, какие могут быть последствия, если нарушить эти правила.
(утечка процессов, CPU, памяти; сложность обнаружения таких проблем; сложность их диагностики)

Итак, есть два правила:
- жизненным циклом процесса кто-то управляет (обычно супервизор);
- все процессы являются частью supervisor tree.

От этого и будем отталкиваться придумывая варианты организации взаимодействия процессов.

Но сначала небольшое предупреждение: все, написаное ниже, не является рекомендациями великих авторитетов, а всего лишь мое личное ИМХО.

TODO: для каждого варианта нужны примеры из практики.


** Вариант №1, каноничный и надежный

Есть два супервизора: sup_1 и sup_2 (в частном случае это может быть один супервизор).

- sup_1 запускает worker_1
- worker_1 просит sup_2 запустить worker_2
- sup_2 запускает worker_2 и возвращает его Pid
- worker_1 устанавливает монитор на этот Pid и обрабатывает сообщения DOWN
- получив сообщение DOWN, worker_1 опять просит sup_2 запустить worker_2

Важный нюанс: sup_2 не должен сам рестартовать worker_2, поэтому restart => temporary.

Здесь worker_1 и sup_2 на двоих делят ответственность за жизненный цикл worker_1.

Вариант концептуально не сложный, но требует достаточно много возни, чтобы все реализовать и ничего не забыть. Повторить это 1-2 раза не проблема. Но утомляет, если придется написать такое 5 и больше раз. Тогда лучше взять вариант, где worker_1 вообще не нужно заботиться о жизненном цикле worker_2 (см ниже).


** Вариант №2, не каноничный

Ну и зачем нам sup_2, если забота о жизненном цикле worker_2 лежит большей частью на worker_1? Пользы от sup_2 тут мало, давайте его уберем.

worker_1 запускает worker_2 и сам линкуется с ним через stark_link.

И тут есть два под-варианта:

Либо worker_1 ставит trap_exit = true и перехватывает краши worker_2. И тем самым берет на себя роль супервизора.

Либо worker_2 этого не делает, и тогда забота о жизненном цикле обоих worker лежит на sup_1. Краш любого из них приводит к рестарту обоих worker на уровне sup_1.


** Вариант №3, медиатор (еще более не каноничный)

Что, если нас не устраивают оба под-варианта №2? С одной стороны, нагружать worker_1 отвественностью супервизора не хочется, у него своей работы хватает, чтобы еще и за чужую браться (именно поэтому выставление trap_exit = true считается плохим тоном). С другой стороны, все-таки хочется, чтобы worker_1 переживал рестарты worker_2.

Тогда между ними создается процесс-медиатор:
worker_1 - start_link - mediator - start_link - worker_2

mediator ставит trap_exit и перехватывает краши обоих worker.
Если крашится worker_2, то медиатор сообщает об этом worker_1, чтобы тот мог принять меры, либо сам рестартует worker_2.
Если крашится worker_1, то медиатор останавливает worker_2 и останавливается сам. Дальше sup_1 решает, что с этим делать.

При отправке сообщений от worker_1 к worker_2 медиатор работает как прокси. То есть, worker_1 отправляет сообщения медиатору, а медиатор передает их worker_2.

Преимущество в том, что это проще, чем вариант №1 и гибче, чем вариант №2.

Я сам не фанат такого варианта, и не использую его в своем коде. С другой стороны, это есть в легаси-коде, и я не спешу это заменить чем-то другим. Работает, и ладно.


** Вариант №4, супервизор-медиатор (непонятно, зачем нужный)

Своего рода продолжение темы с медиатором, только тут на месте медиатора стоит настоящий супервизор, а не просто какой-то кастомный процесс.

w1 - sup - w2

Получается не каноничное дерево супервизоров. В каноничном дереве все воркеры являются листьями, а все узлы -- супервизорами.
А в этом варианте воркер является узлом, и супервизор запускается под воркером.

Это решает проблему, что worker_1 переживает рестарты worker_2. Но не решает проблему взаимодействия, т.к. worker_1 не знает Pid worker_2. Кажется, тем же успехом можно было бы запустить worker_1 и worker_2 под одним супервизором, и все.

Но я видел такое в проектах. Значит, автор считал, что в этом есть какая-то польза. Может кто-то мне подскажет, какая тут есть польза?

TODO: спросить у автора


** Вариант №5, использовать имя, а не Pid

worker_2 регистрируется под каким-то именем, worker_1 просто использует это имя.

Если нужно несколько экземпляров worker_2, то имена для них можно генерировать динамически:

Name = list_to_atom("my_worker_" ++ integer_to_list(Index)).

(Это нарушает еще одно правило -- не генерировать атомы динамически. Но это правило нарушают все, оно не такое уж и страшное :)

Вариант очень удобный, но таит в себе один маленький нюанс: в моменты рестарта worker_2 под нужным именем никто не зарегистрирован. Если в эти моменты делать gen_server:call, то произойдет ошибка (timeout или noproc). А если делать gen_server:cast, то ничего не произойдет. Сообщение никто не обработает, и это останется незамеченым.


** Вариант №6, gproc

Развитие варианта №5. Существует глобальные регистратор процессов, в котором любой процесс может зарегистрироваться под каким-то именем. И любой другой процесс может взаимодействовать через это имя.

Проблема с этим вариантом та же, что и с вариантом №5 -- в моменты рестарта зарегистрированого процесса его имя может быть не валидным.

gproc в кластере еще добавляет распределенность, что порождает проблемы, типичные для распределенных систем: репликация состояния регистратора, его консистентность, латенси работы с ним.


** Вариант #7, worker pool (pooler, poolboy)

Еще один хороший вариант, когда worker_1 не нужно заботиться о жизненном цикле worker_2. Об этом заботится пул. worker_1 может запросить процесс из пула, поработать с ним, и вернуть в пул.

Это довольно удобно, но опять есть нюансы.

Во-первых, возможна утечка процессов из пула, если их запрашивают, но при каких-то условиях не возвращают обратно. За этим надо следить.

Во-вторых, пул может поддерживать динамическое увеличение числа воркеров под нагрузкой. Что хорошо. И динамическое уменьшение их числа, когда нагрузка спадает. И вот с уменьшением опять есть нюансы. Поскольку пул не знает, чем заняты воркеры, он не знает, как их корректно остановить. Хорошо, если он позволяет разработчику как-то управлять этим. А может не позволять, а просто делать brutal kill.

(Так делал poolboy когда-то раньше, когда мы его использовали. Больше не используем, так что я не знаю, что там сейчас.)

brutal kill как минимум забивает error.log шумом (что лично меня не устраивает). Как максимум нам будет неприятно, если воркер умрет, не доделав свою работу до конца.


** Бонус: когда можно нарушить правила

Напомню наши правила:
- жизненным циклом процесса кто-то управляет;
- все процессы являются частью supervisor tree.

Можно просто запустить процесс через spawn, без линка и монитора, если:
- процесс короткоживущий, выполняет одну небольшую задачу и быстро завершается;
- процесс гарантировано завершается (там нет циклов и рекурсий, ну или мы просто очень уверены, что он завершается);
- процесс не крашится, или его краш не несет существенных последствий;
- взаимодействовать с запущеным процессом не нужно (например, не нужно получить от него результат);

Так можно сделать, если мы хотим выполнить какую-то небольшую задачу асинхронно, чтобы не блокировать основной процесс.

TODO: пример такой задачи, поискать в проектах, где-то такое есть.
