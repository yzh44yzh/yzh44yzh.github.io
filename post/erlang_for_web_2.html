<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Erlang для веб. Фреймворки.</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/main.css" />
    <script type="text/javascript" src="../js/main.js"></script>
  </head>
<body>

  <div id="header">
    <div id="main_title">
      <a href="../blog.html" style="color:#013;">Про Erlang и про всякое</a>
    </div>
    <div id="profile_link">
      <a href="https://plus.google.com/u/0/+YuriZhloba/about" style="color:#013;">Юра Жлоба</a>
    </div>
  </div>

<div id="content">


<h1>Erlang для веб. Фреймворки.</h1>
<p><i>2 августа 2014</i><p>

<p>Доклад для 3-й встречи Belarus Erlang User Group.</p>

<h2>Что такое веб-фреймворк?</h2>

<p>Для начала выясним, какие фичи обычно имеет типичный веб-фреймворк.
  Берем за основу самые популярные: Ruby on Rails и Django.</p>
<ul>
<li>Роутинг</li>
  <li>Сессии</li>
  <li>Шаблоны</li>
  <li>ORM
    <ul>
<li>общий интерфейс к разным БД</li>
      <li>генерация схемы БД из модели</li>
      <li>миграция и откат схемы БД</li>
    </ul>
</li>
  <li>Генерация веб-интерфейса для CRUD операций
    <ul>
<li>генерация и валидация форм</li>
      <li>генерация таблиц</li>
    </ul>
</li>
  <li>Кеширование</li>
  <li>Локализация</li>
  <li>Отправка emails</li>
</ul><p>Теперь посмотрим, что из этих фич есть в веб-фреймворках для Erlang, а чего нет.
  И, наоборот, что в Erlang есть такого, чего нет в Rails и Django.</p>

<h2>Chicago Boss</h2>
<p>Первым заслуживает разговора <a href="http://www.chicagoboss.org/">этот фреймворк</a>.
  Развитый, стабильный, неплохо документированный.
  Имеет много достоинств и мало недостатков :)</p>
<p>Автор Chicago Boss, <b>Evan Miller</b>, черпал вдохновение в Ruby on Rails.
  Он попытался сохранить идеологию Rails, и в какой-то мере их архитектуру.
  По мнению автора получилось лучше оригинала, ибо удалось сохранить все хорошее,
  и добавить к этому фичи Erlang :)</p>
<p>Автор, явный сторонник ООП, использовал параметризованные модули и parse transform,
  чтобы сделать код приложения похожим на ООП. Плюс, он скрыл от разработчика
  OTP-архитектуру, предлагая взамен MVC. Тем самым упростил порог входа
  для разработчиков, не знакомых с Erlang.</p>
<p>Известно, что Ruby on Rails, это отдельный мир. И хороший разработчик на рельсах
  совсем не обязательно хорошо знает Ruby и может на нем писать без рельс. Возможно,
  будь Chicago Boss более популярным, аналогичная ситуация могла бы сложиться
  и здесь :)</p>
<p>Вот пример кода:</p>
<div class="highlight highlight-Erlang"><pre>
<span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">person</span><span class="p">,</span> <span class="p">[</span><span class="nv">Id</span><span class="p">,</span> <span class="nv">Name</span><span class="p">,</span> <span class="nv">Age</span><span class="p">]).</span>

<span class="nv">Person</span> <span class="o">=</span> <span class="nn">person</span><span class="p">:</span><span class="nf">new</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="s">"Joe"</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">Person</span><span class="p">:</span><span class="nf">validate</span><span class="p">()</span>
<span class="nv">Person</span><span class="p">:</span><span class="nf">save</span><span class="p">()</span>
</pre></div>
<p>Параметризованными модулями пронизан весь код, и на них нужно остановиться особо.
  Это экспериментальная, не рекомендуемая к использованию и не документированная фича Erlang,
  которая была в языке в версиях R13-R15. А в версии R16 ее убрали.
  Но добавили специальный <a href="https://github.com/erlang/pmod_transform">parse transform</a>, чтобы приложения, использующие эту фичу,
  все таки могли работать на R16. <a href="http://www.erlang.org/news/35">Подробнее тут</a>.
  В итоге Chicago Boss без проблем работает на R16.</p>
<p>Раньше использовался веб сервер Mochiweb, сейчас Cowboy.</p>
<p>Код можно писать не только на Erlang, но и на Elixir, если хочется.</p>

<h3>Фичи фреймворка</h3>

<h4>Роутинг</h4>

<p>Ну понятное дело, какой веб-фреймворк может быть без ротинга?
  Можно пользоваться дефолтным, где по URL и по именам конроллеров определяется,
  какой из них нужно вызывать. И можно задавать свой, кастомный.</p>

<h4>Сессии</h4>

<p>Хранятся в ETS или в Mnesia. Авторизация и привязка запроса к сессии делаются
  до вызова контроллера. Для этого нужно задавать свой hook.</p>

<h4>ORM</h4>

<p>BossRecord, похожий на ActiveRecord из Rails.
  И BossDB, дающий общий интерфейс к разным базам данных.
  Поддерживаются MySQL, PostgreSQL, Riak, MongoDB, Tokyo Tyrant и Mnesia.</p>
<p>В какой-то мере поддерживается миграция и откат схемы БД.</p>

<h4>Шаблоны</h4>

<p>ErlyDTL шаблоны копируют синтаксис шаблонов Django. Компилируются в beam файлы
  (каждый шаблон в отдельный Erlang-модуль). Работают, по утверждению автора, очень быстро.</p>
<p>Их можно использовать отдельно от Chicago Boss.</p>

<h4>Кеширование</h4>

<p>Кеширование моделей реализовано как часть ORM. Кеширование шаблонов не нужно,
  они и так хранятся в оперативной памяти как скомпилированные Erlang-модули.</p>

<h4>Emails</h4>

<p>Хорошая поддержка работы с emails. Получение и отправка писем.
  Конечно с поддержкой ErlyDTL шаблонов.</p>

<h4>Функциональные тесты</h4>

<p>Свой фреймворк для создания и запуска функциональных тестов.</p>
<p>Кроме этого, Chicago Boss, опираясь на возможности Erlang,
  предлагает нетипичные для веб-фреймворков фичи.</p>

<h4>BossMQ</h4>

<p>Своя реализация message queue.</p>

<h4>BossNews</h4>

<p>Событийная модель, рассылка событий, подписка на события.</p>

<h4>WebSocket и long-polling</h4>

<p>Разумеется, с эффективностью, недоступной для Ruby/Python.</p>

<h3>Чего нехватает</h3>

<p>Нет автоматической генерации CRUD-операций из модели.</p>
<p>Формы не генерируются, нужно вручную делать шаблоны для них.</p>
<p>Функции валидации форм нужно писать вручную.</p>
<p>Нет генерации схемы БД из модели.</p>
<p>Так что тут не получится, как в Django, просто описав модель данных, сразу получить
  полноценный CRUD веб-интерфейс. Придется еще поработать ручками :)</p>
<p><b>UPD</b> оказывается это есть <a href="https://github.com/ChicagoBoss/cb_admin">Admin interface for Chicago Boss</a>, просто не документировано.</p>
<p>Локализация в какой-то мере поддерживается, но я не вникал, не скажу подробностей.</p>

<h3>Итого</h3>

<p>Проект зрелый, развивается с 2010 года. &gt; 1200 комитов, 54 контрибьютора.</p>
<p>В вики есть список сайтов, <a href="https://github.com/ChicagoBoss/ChicagoBoss/wiki/List-of-public-websites-built-with-Chicago-Boss">построенных на Chicago Boss</a>.
  Там не густо. Но отметим среди них <a href="http://www.erlang-factory.com/">erlang-factory.com</a>.</p>
<p>Самый развитый веб-фреймворк для Erlang. И лично я выбрал бы именно его.</p>

<h2>Nitrogen</h2>

<p><a href="http://nitrogenproject.com/">Нестандартный проект</a>, который не пытается повторить фичи MVC фрейворков, а идет своим путем.
  Этот фреймворк предназначен не для сайтов, а для интерактивных веб-приложений.</p>
<p>Есть такой термин RIA - Rich Internet Applications. Вот именно для них. Это могут быть
  приложения типа facebook, с обновляемым в реальном времени контентом; чаты, игры,
  какие-нибудь бизнес-приложения с таблицами и графиками и т.д.</p>
<p>Идея в том, что сперва на клиент отдается html-страница, и с нее клиентский JS-код
  с помощью long-polling активно общаться с сервером. Клиентские события: нажатия на кнопку,
  перетаскивания и т.д. идут на сервер, с сервера идут данные и отображаются на клиенте.</p>
<p>Nitrogen предлагает свой DSL, построенный на record, для описания интерфейса средствами HTML
  и для связывания клиентских событий с обработчиками на сервере.</p>
<p>Работает поверх разных веб-серверов, в т.ч. поверх Cowboy.</p>

<h3>Фичи фреймворка</h3>

<ul>
<li>Роутинг</li>
  <li>DSL для описания интерфейса и событий</li>
  <li>Сессии, хранение состояния на клиенте и на сервере</li>
  <li>Валидация форм</li>
  <li>Связь клиента и сервера через long polling</li>
</ul>

<h3>Чего нет</h3>

<p>Нету WebSockets, что, конечно, странно для такого проекта. Может я и ошибаюсь, но я не нашел
  инфы о том, что WebSockets поддерживаются.</p>
<p>Нет какой-либо работы с базой данных.</p>
<p>Нет готовых CRUD операций.</p>
<p>Его DSL-язык вынуждает программиста самому возиться с макетом, полученным от дизайнера.
  HTML-верстальщика не посадишь создавать интерфейс.</p>

<h3>Итого</h3>

<p>Это один из первых Erlang-фреймворков, начался в 2008 году.
  Но не такой активный, как Chicago Boss: &gt; 800 commits, 24 контрибьютора.</p>
<p>Документирован неплохо: API, туторы, примеры.
  Но нет обзорной документации, описывающей идеологию и архитектуру.</p>
<p>Узкоспециализированный, нишевый продукт с ограниченными возможностями.</p>
<p>Имеет смысл использовать только если вам очень нравится его DSL.
  Иначе аналогичные приложения можно строить и без него,
  используя богатые клиентские JS-библиотеки, и REST API на сервере.</p>

<h2>N2O</h2>

<p>Фреймворк <a href="https://synrc.com/apps/n2o/doc/web/">Nitrogen 2 Optimized</a> – наследник Nitrogen.
  Создан Максимом Сохацким из Киева.
  Максим долгое время работал над крупным веб-проектом: социальной сетью с онлайн играми,
  и изначально использовал там Nitrogen. По ходу работы Nitrogen сильно дорабатывался,
  и по фичам, и по производительности, и по чистоте кода. В результате практически
  полностью был переписан.</p>
<p>Разумеется, N2O использует WebSockets. Позволяет подключить любой клиентский JS-фреймворк
  и свой JS-код. Позволяет использовать вместо Nitrogen DSL другие шаблоны (ErlyDTL например).</p>
<p>И предлагает несколько своих библиотек:</p>
<p>KVS – общий интерфейс к noSQL/key-value базам данных.
  Из которых сейчас поддерживаются Mnesia, RIAK и KAI.
  (Реляционные базы не поддерживаются самой идеологией этой библиотеки.)</p>
<p>AVZ – библиотека авторизации через Facebook, Google, Twitter, Github, Microsoft.</p>
<p>MQS – библиотека для RabbitMQ.</p>
<p>Есть и другие.</p>
<p>Итого, сейчас нет причин использовать оригинальный Nitrogen, и для RIA проектов лучше брать N2O.</p>

<h2>Zotonic</h2>

<p>Про <a href="http://zotonic.com/">Zotonic</a> пару слов.</p>
<p>Это веб-фреймворк и CMS, но, похоже, больше CMS, нежели фреймворк.
  И сравнивать его нужно скорее с Drupal или Joomla, чем с Rails :)</p>
<p>Ну нормальная такая CMS с обычными для такого рода продуктов фичами.
  Но обещает большую скорость и стабильность.</p>
<p>Проект старый, с 2009 года.</p>
<p>Итого: не знаю, для кого это. Но раз проект живет, значит он кому-то нужен :)</p>

<h2>Выводы по фреймворкам</h2>

<p>ChicagoBoss предлагает
  <a href="https://github.com/ChicagoBoss/ChicagoBoss/wiki/Comparison-of-Erlang-Web-Frameworks">сравнительную таблицу</a> фич разных фремворков. Познавательно :)</p>
<p>Ну так что мы имеем?</p>
<p>Один неплохой классический MVC фреймворк: ChicagoBoss.</p>
<p>Один фреймворк для RIA приложений: N2O
  (использовать оригинальный Nitrogen вроде бы нет причин).</p>
<p>Одна кому-то нужная CMS: Zotonic.</p>
<p>Однако эти фреймворки не пользуются особой популярностью даже среди Erlang-программистов.
  И причины тут понятны: на Erlang просто не делают таких проектов, где был бы нужен
  MVC-фреймворк, CRUD, ORM и т.д. Потому, что эти проекты проще делать на Rails, Django и т.д.
  Есть разработчики, есть большой опыт, есть много успешных проектов.
  Erlang можно использовать в таких проектах для каких-то специфических целей,
  дополняя, а не заменяя Rails/Django. Что и делается в компании, где я работаю.</p>

<h2>Пару слов о моих веб-проектах на Erlang</h2>

<p>У меня есть 3 веб-проекта на Erlang, разной сложности, с разными подходами.
  Не знаю, можно ли их назвать “типовыми”, но как пример использовать можно.</p>

<h3>Проект №1</h3>

<p>Многопользовательская онлайновая игра.</p>
<p>iOS клиент с постоянным TCP-соединением.
  Со стороны сервера <a href="https://github.com/ninenines/ranch">Ranch Acceptor Pool</a>.
  Bert-сериализация данных.</p>
<p>Flash-клиент. Со стороны сервера cowboy, json-сериализация.</p>
<p>Веб-админка, показывающая различную статистику и позволяющая управлять разными настройками.
  Cowboy, ErlyDTL шаблоны, самодельная валидация форм. Работа с базой напрямую, голый SQL.</p>
<p>Тут можно было бы применить ChicagoBoss, а можно и не применять, админка простая.</p>

<h3>Проект №2</h3>

<p>Информационный веб-ресурс. Сложная структура базы данных, сложные запросы, большей частью SELECT.
  Запросов, модифицирующих базу, мало.
  Однако нужна админка с полноценными CRUD операциями ко всем объектам в базе.</p>
<p>Админка сделана на Django/Python, схема базы (MySQL) сгенерирована из Django-модели.
  Пользовательская часть: Cowboy, голые SQL запросы, хранение сессий в Memcache, XSL шаблоны.</p>
<p>Для такого проекта ChicagoBoss можно использовать. Но в компании уже существовало некое
  свое решение на Erlang, не фреймворк, но архитектурный подход и набор библиотек. Которое
  мне и предложили использовать и развивать дальше. Это решение меня в целом устраивает,
  за исключением XSL шаблонов. Очень уж они корявые и многословные. Но с шаблонами я сам не работаю,
  работает верстальщик, и он это умеет. Если бы с шаблонами нужно было работать мне самому,
  я бы настаивал на ErlyDTL.</p>

<h3>Проект №3</h3>

<p>Ну это главный проект компании: онлайн кинотеатр <a href="http://www.tvzavr.ru/">tvzavr.ru</a>.</p>
<p>Он сделан на Python/Django/MySQL. Сложный проект, с большой кодовой базой.
  Код там может и не самый красивый, но архитектурно сделано все довольно грамотно.
  Так, что сейчас есть пространство для маневра, если нужны доработки и оптимизации
  производительности. А они нужны постоянно :)</p>
<p>Одним из важных решений было разделение контента страницы на общий, одинаковый для
  всех пользователей, и индивидуальный для каждого пользователя.
  Общий контент страницы рендерится питоном из шаблона, отдается пользователю,
  и кешируется на уровне nginx.
  Индивидуальный контент запрашивается браузером отдельно, JS-запросами к веб АПИ.</p>
<p>В итоге есть две системы: основной сайт и веб АПИ. Которые можно
  развивать и оптимизировать независимо друг от друга. Они связаны через базу,
  и через Memcache (где хранятся сессии и другие важные данные).</p>
<p>Веб АПИ изначально тоже было на питоне. Но сейчас где-то половина его,
  наиболее нагруженная, переписана на эрланге. И я делаю следующую версию АПИ
  уже целиком на эрланге.</p>


<div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = 'yzh44yzh';

(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>
</body>
</html>
