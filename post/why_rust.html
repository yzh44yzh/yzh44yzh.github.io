<h1>На каком языке программирования я (мы) буду (будем) писать завтра?</h1>

У всех у нас (программистов) есть какой-то набор языков программирования, которые нам нравятся, и которые мы применяем. Конечно, этот набор со временем меняется.

Кому-то интересно запускать бизнесы, кому-то интересно выпускать продукты, а кому-то интересны сами по себе технологии, как таковые (и языки программирования, как частный случай). Постоянно хочется найти и изучить что-то, что лучше и интереснее.


<h2>Что мне нравится</h2>

Мне нравится функциональное программирование, потому что оно проще (ИМХО), а я люблю простые вещи. Но ФП бывает разное. Есть два больших семейства языков: семейство LISP и семейство ML.

Я попробовал много языков, и у меня сложился определенный вкус -- больше всего мне нравятся языки семейства ML. Не думаю, что это рациональный выбор, хотя при желании его можно рационально обосновать. Для меня тут скорее эстетический момент. Концепции, семантика этих языков мне кажутся красивыми и элегантными. Хотя не всегда элегантным кажется синтаксис (да, это про Scala).

В свое время я инвестировал довольно много времени и сил в изучение многих их них. Это было примерно так:
- Haskell
- Standard ML
- еще раз Haskell
- Scala
- еще раз Haskell
- OCaml
- еще раз Haskell
- еще раз Scala
- Elm
- F#
- еще раз OCaml

То есть, я попробовал всех основных игроков: <b>Haskell</b>, <b>Scala</b>, <b>OCaml</b>, <b>F#</b>, и я делал по несколько подходов к каждому из них.

Тут можно было бы порассуждать о каждом из них в отдельности. Но, может быть, как-нибудь в другой раз. Сейчас хочется поговорить о семействе в целом.


<h2>Что такое ML?</h2>

Лучше порассуждаю о концепциях, лежащих в основе этих языков.

<h3>Immutable programming</h3>

Характерно для всех ФП языков.

<h3>First-class functions</h3>

<h3>Static type-checking</h3>

<h3>Automatic type inference</h3>

<h3>Algebraic data types</h3>

<h3>Pattern matching</h3>

<h3>Parametric polymorphism</h3>



В языке, который я выберу, мне нужны все эти фичи.


<h2>Что у меня есть сейчас</h2>

Erlang хорош. Простой, не дающий мощных абстракций, а просто делающий свою работу. Этим и хорош.

Да, это ML язык. Но при том, что он поддерживает все фичи ML, на самом деле Erlang не про ML, и вообще не про ФП. Не про моделирование сложных данных, и не про композиции операций над данными.

Erlang про то, чтобы эффективно направить потоки данных откуда-то куда-то. Это язык водопроводчиков, он про трубы и бассейны, как в школьных задачах: сюда затекает столько-то, отсюда вытекает столько-то, смотри, чтобы бассейн не переполнился. Вернее, у тебя десятки бассейнов и сотни труб, разложены на пять нод (а у кого-то на 50, или на 500 нод). Но суть та же -- все должно быстро течь, не засоряться, и не переполняться.

Это нишевый язык под узкие задачи.

Все это интересно, и я с удовольствием занимаюсь этим уже лет 7, что ли. Но вряд ли я буду заниматься этим всю жизнь. Когда-нибудь мне надоест быть водопроводчиком :)

Elixir лучше, мощнее Erlang. Это, очевидно, большой шаг вперед. Много фич, которые действительно улучшают жизнь разработчику, по сравнению с аскетичным Erlang.

Но кое-что мне сильно не нравится. Да, формально Elixir является ФП языком и имеет все фичи ML языков. Но авторы языка сделали все как-то не так, не с тем духом и не с той эстетикой. Во-первых, потому, что авторам чужды дух и эстетика ML. Во-вторых потому, что лучше сделать и не могли из-за ограничений своего дизайна. Очевидно, что дизайн языка не был продуман изначально, а сформировался случайным образом.

Сфера применения Elixir шире. Но я не уверен, что его можно считать языком общего назначения. Все-таки это тоже специализированый язык под конкретные области применения.

Еще у меня есть Python, но я его никогда особо не любил. Он есть, потому постоянно для чего-то нужен.
Тут задеплоить, тут автоматизировать, тут данные переложить из одной БД в другую.
Я не писал на нем ничего большого и серьезного. Но по-мелочи он везде нужен.

Хочется иметь в своем арсенале хороший язык общего назначения. Да, Python такой. Да его можно рассматривать как полноценный инструмент для больших проектов. (Тем более, что в Варгейминге полно таких проектов на Python). Но это просто не интересно. Это шаг назад.

(Но своего сына я буду учить в первую очередь Python)


<h2>На чем я буду писать завтра?</h2>

Rust имеет все фичи, присущие семейству ML. На нем можно писать в функциональном стиле, хотя это сильно отличается от других языков. Но в отличие от Elixir, отличается не потому, что авторам так захотелось, а потому что на это есть веская причина -- управление памятью.

Эффективный нативный код.
Zero cost abstractions.
Хороший тулинг -- cargo.

Хорошие книги и документация. Нехватает хороших упражнений, rustling -- ерунда какая-то. Но это поправимо.


<h2>Прогнозы глобального масштаба :)</h2>

В основе современного IT лежат технологии, созданные в 70-80х годах: ОС Unix, Сеть TCP/IP, Реляционные БД.
Все это развивается, конечно. Но и обрастает слоями легаси.

Ядро линукса огромно. Поверх ядра есть дистрибутивы линукса. Поверх них есть витруальные машины. Поверх них есть докер. Поверх докера -- кубернетис. Кластеры, облака. Тонкое управление огромным количеством распределенных ресурсов. Все это построено поверх легаси с большим оверхедом.

Все это когда-то достигнет своего предела, и под грузом легаси и оверхеда не сможет дальше эффективно развиваться.

А тем временем новые, легковесные ОС появятся из ниоткуда (а их пишут), и потеснят линукс с серверов.
(Что там будет с персональными и мобильными компьютерами я гадать не возьмусь, мне это не так интересно).

Когда-то появятся молодые и дерзкие технологии, и потеснят ветеранов индустрии. Может быть это случится через 5 лет, может через 10, а может и завтра.

На каких ЯП будут написаны эти технологии? А что у нас вообще есть из ЯП, пригодного для системного программирования, с эффективным управлением ресурсами (памятью)?

C, C++ -- основные трудяги
Ada, Eiffell -- неизвестные маргиналы
D, ... -- невзлетевшие убийцы C++
Ну и свежее: Rust, Swift.

Ну ладно, мы же с вами не системные программисты, и не будем писать ядро ОС. Будем писать прикладной софт. Может, мы может отказаться от GC? А если это не так сложно, как казалось? Ну вообще сложно, да, придется разобраться, как лежат наши данные в памяти, что там на стеке, а что в куче. Но если не запредельно сложно, посильно? Может, мы захотим использовать ресурсы железа на 1-2 порядка эффективнее?

Ну вот поэтому Rust :) Во всяком случае, это интереснее, чем Expert Python Programming by Tarek Ziadé.
(Ну не тянет меня в мейнстрим, и никогда не тянуло)


<h2>Ссылки</h2>

Самая лучшая книга по ФП: Domain modeling made functional

В чем фишка Rust: видео про тормозные системы в поездах
