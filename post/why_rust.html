<h1>На каком языке программирования я (мы) буду (будем) писать завтра?</h1>

У всех у нас (программистов) есть какой-то набор языков программирования, которые нам нравятся, и которые мы применяем. Конечно, этот набор со временем меняется.

Кому-то интересно запускать бизнесы, кому-то интересно выпускать продукты, а кому-то интересны сами по себе технологии, как таковые (и языки программирования, как частный случай). Постоянно хочется найти и изучить что-то, что лучше и интереснее.


<h2>Что мне нравится</h2>

Мне нравится функциональное программирование, потому что оно проще, а я люблю простые вещи. Но ФП бывает разное. Есть два больших семейства языков: семейство LISP и семейство ML.

Я попробовал много языков, и у меня сложились определенные предпочтения &mdash; больше всего мне нравятся языки <a href="https://ru.wikipedia.org/wiki/ML">семейства ML</a>. Не скажу, что это продуманый, рациональный и глубоко обоснованый выбор, скорее дело вкуса. Хотя при желании его можно рационально обосновать. Концепции, семантика этих языков мне кажутся красивыми и элегантными. (Синтаксис не всегда таким кажется, особенно если речь идет про Scala, но синтаксис вторичен).

В свое время я инвестировал довольно много времени и сил в изучение многих их них. Это было примерно так:
- Haskell
- Standard ML
- еще раз Haskell
- Scala
- еще раз Haskell
- OCaml
- еще раз Haskell
- еще раз Scala
- Elm
- F#
- еще раз OCaml

То есть, я попробовал всех основных игроков: <b>Haskell</b>, <b>Scala</b>, <b>OCaml</b>, <b>F#</b>, и я делал по несколько подходов к каждому из них.

Тут можно было бы порассуждать о каждом языке отдельно. Но это слишком большая тема. Может быть, как-нибудь в другой раз. Сейчас хочется поговорить о всем семействе в целом.


<h2>Что такое ML?</h2>

Семейство можно определить по происхождению от общего родителя &mdash; языка ML (Meta Language), разработаного <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BB%D0%BD%D0%B5%D1%80,_%D0%A0%D0%BE%D0%B1%D0%B8%D0%BD">Робином Милнером</a> в далеком 1973 году. Несмотря на академическое происхождение, сам язык ML и его потомки оказались практичными и удобными, за счет некоторого небольшого набора концепций, лежащих в его основе.


<h3>Immutable Programming</h3>

<b>Неизменяемые структуры данных</b> уменьшают возможности для появления ошибок. Тем самым урощают жизнь программисту, позволяют ему меньше думать о том, где и как могут возникнуть ошибки.

Они же упрощают многопоточное программирование, исключая ситуации race condition, когда два разных потока одновременно модифицируют некие данные.

Обратная сторона -- операции над этими данными менее производительные, чем операции над мутабельными данными. Считается, что разница в производительности в среднем не такая большая. Но это "в среднем", а в крайних случаях производительность может отличаться сильно.

Полезность концепции подтверждает ее активное проникновение из ФП в мейнстримовые языки.


<h3>First-Class Functions (High Order Functions, HOF)</h3>

<b>Функции высшего порядка</b> &mdash; важный способ абстрагирования кода, лежаший в основе работы с любыми коллекциями (списками, массивами, векторами и т.д.). Они меняют сам подход к такой работе, в сравнении с процедурным программированием.

Циклы и доступ к элементам коллекции по индексам &mdash; это операции низкого уровня. Вместо них предлагаются более высокоуровневые операции &mdash; map, filter, fold и др. Это тоже уменьшает возможности для появления ошибок.

HOF так же активно проникают из ФП в мейнстримовые языки.


<h3>Static Type-Checking</h3>

<b>Статическая типизация</b> &mdash; это то, что отличает ML от LISP. Большинство ML языков имеют статическую типизацию, а все LISP языки динамически типизированы.

Останавливаться на преимуществах и недостатках того и другого сейчас не будем.


<h3>Automatic Type Inference</h3>

<b>Автоматический вывод типов</b> &mdash; важное дополнение к статической типизации, которое сильно упрощает жизнь программисту. Нет необходимости везде и всюду явно указывать типы, так как во многих случаях компилятор может сам вывести нужный тип.

Это еще одна концепция, которая востребована в мейнстримовых языках.


<h3>Algebraic Data Types</h3>

<b>Алгебраические типы данных</b> &mdash; основной способ моделирования данных.
TODO stopped here
В отличие от ООП.


<h3>Pattern Matching</h3>

Киллер-фича, которая, к сожалению, в мейнстримовые языки проникает с трудом и в урезаном виде.

Реализует разбор сложных структур данных на составные части и условные переходы. Обычно делает и то, и другое одновременно, что дает лаконичный и выразительный код.


<h3>Parametric Polymorphism</h3>

Достигается во многом за счет описаных выше фич: HOF, ADT и PM.



В языке, который я выберу, мне нужны все эти фичи. Поэтому меня не тянет в мейнстримовые языки. IP и HOF туда проникли, STC и ATI там и так были, а вот с ADT и PM все плохо. Обойтись без ADT и PM я, конечно, могу. Но зачем? Отказаться от удобных фич, чтобы что? Нет уж, ADT и PM мне нужны :)


<h2>Что у меня есть сейчас</h2>

Erlang хорош. Простой, не дающий мощных абстракций, а просто делающий свою работу. Этим и хорош.

Да, это ML язык. Но при том, что он поддерживает все фичи ML, на самом деле Erlang не про ML, и вообще не про ФП. Не про моделирование сложных данных, и не про композиции операций над данными.

Erlang про то, чтобы эффективно направить потоки данных откуда-то куда-то. Это язык водопроводчиков, он про трубы и бассейны, как в школьных задачах: сюда затекает столько-то, отсюда вытекает столько-то, смотри, чтобы бассейн не переполнился. Вернее, у тебя десятки бассейнов и сотни труб, разложены на пять нод (а у кого-то на 50, или на 500 нод). Но суть та же -- все должно быстро течь, не засоряться, и не переполняться.

Это нишевый язык под узкие задачи.

Все это интересно, и я с удовольствием занимаюсь этим уже лет 7, что ли. Но вряд ли я буду заниматься этим всю жизнь. Когда-нибудь мне надоест быть водопроводчиком :)

Elixir лучше, мощнее Erlang. Это, очевидно, большой шаг вперед. Много фич, которые действительно улучшают жизнь разработчику, по сравнению с аскетичным Erlang.

Но кое-что мне сильно не нравится. Да, формально Elixir является ФП языком и имеет все фичи ML языков. Но авторы языка сделали все как-то не так, не с тем духом и не с той эстетикой. Во-первых, потому, что авторам чужды дух и эстетика ML. Во-вторых потому, что лучше сделать и не могли из-за ограничений своего дизайна. Очевидно, что дизайн языка не был продуман изначально, а сформировался случайным образом.

Сфера применения Elixir шире. Но я не уверен, что его можно считать языком общего назначения. Все-таки это тоже специализированый язык под конкретные области применения.

Еще у меня есть Python, но я его никогда особо не любил. Он есть, потому постоянно для чего-то нужен.
Тут задеплоить, тут автоматизировать, тут данные переложить из одной БД в другую.
Я не писал на нем ничего большого и серьезного. Но по-мелочи он везде нужен.

Хочется иметь в своем арсенале хороший язык общего назначения. Да, Python такой. Да его можно рассматривать как полноценный инструмент для больших проектов. (Тем более, что в Варгейминге полно таких проектов на Python). Но это просто не интересно. Это шаг назад.

(Но своего сына я буду учить в первую очередь Python)


<h2>На чем я буду писать завтра?</h2>

Rust имеет все фичи, присущие семейству ML. На нем можно писать в функциональном стиле, хотя это сильно отличается от других языков. Но в отличие от Elixir, отличается не потому, что авторам так захотелось, а потому что на это есть веская причина -- управление памятью.

Эффективный нативный код.
Zero cost abstractions.
Хороший тулинг -- cargo.

Хорошие книги и документация. Нехватает хороших упражнений, rustling -- ерунда какая-то. Но это поправимо.


<h2>Прогнозы глобального масштаба :)</h2>

В основе современного IT лежат технологии, созданные в 70-80х годах: ОС Unix, Сеть TCP/IP, Реляционные БД.
Все это развивается, конечно. Но и обрастает слоями легаси.

Ядро линукса огромно. Поверх ядра есть дистрибутивы линукса. Поверх них есть витруальные машины. Поверх них есть докер. Поверх докера -- кубернетис. Кластеры, облака. Тонкое управление огромным количеством распределенных ресурсов. Все это построено поверх легаси с большим оверхедом.

Все это когда-то достигнет своего предела, и под грузом легаси и оверхеда не сможет дальше эффективно развиваться.

А тем временем новые, легковесные ОС появятся из ниоткуда (а их пишут), и потеснят линукс с серверов.
(Что там будет с персональными и мобильными компьютерами я гадать не возьмусь, мне это не так интересно).

Когда-то появятся молодые и дерзкие технологии, и потеснят ветеранов индустрии. Может быть это случится через 5 лет, может через 10, а может и завтра.

На каких ЯП будут написаны эти технологии? А что у нас вообще есть из ЯП, пригодного для системного программирования, с эффективным управлением ресурсами (памятью)?

C, C++ -- основные трудяги
Ada, Eiffell -- неизвестные маргиналы
D, ... -- невзлетевшие убийцы C++
Ну и свежее: Rust, Swift.

Ну ладно, мы же с вами не системные программисты, и не будем писать ядро ОС. Будем писать прикладной софт. Может, мы может отказаться от GC? А если это не так сложно, как казалось? Ну вообще сложно, да, придется разобраться, как лежат наши данные в памяти, что там на стеке, а что в куче. Но если не запредельно сложно, посильно? Может, мы захотим использовать ресурсы железа на 1-2 порядка эффективнее?

Ну вот поэтому Rust :) Во всяком случае, это интереснее, чем Expert Python Programming by Tarek Ziadé.
(Ну не тянет меня в мейнстрим, и никогда не тянуло)


<h2>Ссылки</h2>

Самая лучшая книга по ФП: Domain modeling made functional

В чем фишка Rust: видео про тормозные системы в поездах
