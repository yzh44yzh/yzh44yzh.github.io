<h1>На каком языке программирования я (мы) буду (будем) писать завтра?</h1>

У всех у нас есть какой-то набор языков программирования, которые нам нравятся, и которые мы применяем. Конечно, этот набор со временем меняется.


<h2>Что мне нравится</h2>

ФП
но не любое
в ФП есть два больших семейства языков: семейство LISP и семейство ML.

За годы карьеры у меня сложился определенный вкус к языкам программирования. Больше всего мне нравятся языки семейства ML. В свое время я инвестировал довольно много времени и сил в изучение большинства их них. Это было примерно в такой очередности:
- Haskell
- Standard ML (не прикладной язык, но эталон для всего семейства)
- еще раз Haskell
- Scala
- еще раз Haskell
- OCaml
- еще раз Haskell
- еще раз Scala
- Elm
- F#
- еще раз OCaml

То есть, я попробовал всех основных игроков: Haskell, Scala, OCaml, F#, и я делал по несколько подходов к каждому из них.


<h2>Что такое ML?</h2>

Immutable programming
First-class functions

Static type-checking
Automatic type inference

Algebraic data types
Pattern matching

Parametric polymorphism

В языке, который я выберу, мне нужны все эти фичи.


<h2>Что у меня есть сейчас</h2>

Erlang хорош. Простой, не дающий мощных абстракций, а просто делающий свою работу. Этим и хорош.

Да, это ML язык. Но при том, что он поддерживает все фичи ML, на самом деле Erlang не про ML, и вообще не про ФП. Не про моделирование сложных данных, и не про композиции операций над данными.

Erlang про то, чтобы эффективно направить потоки данных откуда-то куда-то. Это язык водопроводчиков, он про трубы и бассейны, как в школьных задачах: сюда затекает столько-то, отсюда вытекает столько-то, смотри, чтобы бассейн не переполнился. Вернее, у тебя десятки бассейнов и сотни труб, разложены на пять нод (а у кого-то на 50, или на 500 нод). Но суть та же -- все должно быстро течь, не засоряться, и не переполняться.

Это нишевый язык под узкие задачи.

Все это интересно, и я с удовольствием занимаюсь этим уже лет 7, что ли. Но вряд ли я буду заниматься этим всю жизнь. Когда-нибудь мне надоест быть водопроводчиком :)

Elixir лучше, мощнее Erlang. Это, очевидно, большой шаг вперед. Много фич, которые действительно улучшают жизнь разработчику, по сравнению с аскетичным Erlang.

Но кое-что мне сильно не нравится. Да, формально Elixir является ФП языком и имеет все фичи ML языков. Но авторы языка сделали все как-то не так, не с тем духом и не с той эстетикой. Во-первых, потому, что авторам чужды дух и эстетика ML. Во-вторых потому, что лучше сделать и не могли из-за ограничений своего дизайна. Очевидно, что дизайн языка не был продуман изначально, а сформировался случайным образом.

Сфера применения Elixir шире. Но я не уверен, что его можно считать языком общего назначения. Все-таки это тоже специализированый язык под конкретные области применения.

Еще у меня есть Python, но я его никогда особо не любил. Он есть, потому постоянно для чего-то нужен.
Тут задеплоить, тут автоматизировать, тут данные переложить из одной БД в другую.
Я не писал на нем ничего большого и серьезного. Но по-мелочи он везде нужен.

Хочется иметь в своем арсенале хороший язык общего назначения. Да, Python такой. Да его можно рассматривать как полноценный инструмент для больших проектов. (Тем более, что в Варгейминге полно таких проектов на Python). Но это просто не интересно. Это шаг назад.

(Но своего сына я буду учить в первую очередь Python)


<h2>На чем я буду писать завтра?</h2>

Rust имеет все фичи, присущие семейству ML. На нем можно писать в функциональном стиле, хотя это сильно отличается от других языков. Но в отличие от Elixir, отличается не потому, что авторам так захотелось, а потому что на это есть веская причина -- управление памятью.

Эффективный нативный код.
Zero cost abstractions.
Хороший тулинг -- cargo.

Хорошие книги и документация. Нехватает хороших упражнений, rustling -- ерунда какая-то. Но это поправимо.


<h2>Прогнозы глобального масштаба :)</h2>

В основе современного IT лежат технологии, созданные в 70-80х годах: ОС Unix, Сеть TCP/IP, Реляционные БД.
Все это развивается, конечно. Но и обрастает слоями легаси.

Ядро линукса огромно. Поверх ядра есть дистрибутивы линукса. Поверх них есть витруальные машины. Поверх них есть докер. Поверх докера -- кубернетис. Кластеры, облака. Тонкое управление огромным количеством распределенных ресурсов. Все это построено поверх легаси с большим оверхедом.

Все это когда-то достигнет своего предела, и под грузом легаси и оверхеда не сможет дальше эффективно развиваться.

А тем временем новые, легковесные ОС появятся из ниоткуда (а их пишут), и потеснят линукс с серверов.
(Что там будет с персональными и мобильными компьютерами я гадать не возьмусь, мне это не так интересно).

Когда-то появятся молодые и дерзкие технологии, и потеснят ветеранов индустрии. Может быть это случится через 5 лет, может через 10, а может и завтра.

На каких ЯП будут написаны эти технологии? А что у нас вообще есть из ЯП, пригодного для системного программирования, с эффективным управлением ресурсами (памятью)?

C, C++ -- основные трудяги
Ada, Eiffell -- неизвестные маргиналы
D, ... -- невзлетевшие убийцы C++
Ну и свежее: Rust, Swift.

Ну ладно, мы же с вами не системные программисты, и не будем писать ядро ОС. Будем писать прикладной софт. Может, мы может отказаться от GC? А если это не так сложно, как казалось? Ну вообще сложно, да, придется разобраться, как лежат наши данные в памяти, что там на стеке, а что в куче. Но если не запредельно сложно, посильно? Может, мы захотим использовать ресурсы железа на 1-2 порядка эффективнее?

Ну вот поэтому Rust :) Во всяком случае, это интереснее, чем Expert Python Programming by Tarek Ziadé.
(Ну не тянет меня в мейнстрим, и никогда не тянуло)


<h2>Ссылки</h2>

Самая лучшая книга по ФП: Domain modeling made functional

В чем фишка Rust: видео про тормозные системы в поездах
