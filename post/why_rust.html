<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>На каком языке программирования я/мы буду/будем писать завтра?</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/main.css" />
    <link rel="stylesheet" href="../css/hl_styles/default.css">
</head>
<body>

<div id="header">
    <div id="main_title">
        <a href="../blog.html" style="color:#013;">Про Erlang и про всякое</a>
    </div>
    <div id="profile_link">
        <a href="https://www.facebook.com/yuri.zhloba" style="color:#013;">Юра Жлоба</a>
    </div>
</div>

<div id="content">

<h1>На каком языке программирования я/мы буду/будем писать завтра?</h1>
<p><i>31 июля 2019</i></p>

<p>У всех у нас (программистов) есть какой-то набор языков программирования, которые нам нравятся, и которые мы применяем. Конечно, этот набор со временем меняется.</p>

<p>Кому-то интересно запускать бизнесы, кому-то интересно выпускать продукты, а кому-то интересны сами по себе технологии, как таковые (и языки программирования, как частный случай). Постоянно хочется найти, изучить и применить что-то, что лучше и интереснее.</p>


<h2>Что мне нравится</h2>

<p>Мне нравится функциональное программирование, потому что оно проще, а я люблю простые вещи. Но ФП бывает разное. Есть два больших семейства языков: семейство LISP и семейство ML.</p>

<p>Я попробовал много языков, и у меня сложились определенные предпочтения &mdash; больше всего мне нравятся языки <a href="https://ru.wikipedia.org/wiki/ML">семейства ML</a>. Не скажу, что это продуманный, рациональный и глубоко обоснованный выбор, скорее дело вкуса. Хотя при желании его можно рационально обосновать. Концепции, семантика этих языков мне кажутся красивыми и элегантными. (Синтаксис не всегда таким кажется, особенно если речь идет про Scala, но синтаксис вторичен).</p>

<p>В свое время я инвестировал довольно много времени и сил в изучение многих их них. Это было примерно так:
<ul>
<li>Haskell</li>
<li>Standard ML</li>
<li>еще раз Haskell</li>
<li>Scala</li>
<li>еще раз Haskell</li>
<li>OCaml</li>
<li>еще раз Haskell</li>
<li>еще раз Scala</li>
<li>Elm</li>
<li>F#</li>
<li>еще раз OCaml</li>
</ul></p>

<p>То есть, я попробовал всех основных игроков: <b>Haskell</b>, <b>Scala</b>, <b>OCaml</b>, <b>F#</b>, и сделал по несколько подходов к каждому из них.</p>

<p>Тут можно было бы порассуждать о каждом языке отдельно. Но это слишком большая тема. Может быть, как-нибудь в другой раз. Сейчас хочется поговорить о всем семействе в целом.</p>


<h2>Что такое ML?</h2>

<p>Семейство можно определить по происхождению от общего родителя &mdash; языка ML (Meta Language), разработаного <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BB%D0%BD%D0%B5%D1%80,_%D0%A0%D0%BE%D0%B1%D0%B8%D0%BD">Робином Милнером</a> в далеком 1973 году. Несмотря на академическое происхождение, сам язык ML и его потомки оказались практичными и удобными, за счет некоторого небольшого набора концепций, лежащих в его основе.<p>


<h3>Immutable Programming</h3>

<p>Неизменяемые структуры данных уменьшают возможности для появления ошибок. Тем самым урощают жизнь программисту, позволяют ему меньше думать о том, где и как могут возникнуть ошибки.</p>

<p>Они же упрощают многопоточное программирование, исключая ситуации race condition, когда два разных потока одновременно модифицируют некие данные.</p>

<p>Обратная сторона -- операции над этими данными менее производительные, чем операции над мутабельными данными. Считается, что разница в производительности в среднем не такая большая. Но это "в среднем", а в крайних случаях производительность может отличаться сильно.</p>

<p>Полезность концепции подтверждает ее активное проникновение из ФП в мейнстримовые языки.</p>


<h3>First-Class Functions (High Order Functions, HOF)</h3>

<p>Функции высшего порядка &mdash; важный способ абстрагирования кода, лежаший в основе работы с любыми коллекциями (списками, массивами, векторами и т.д.). Они меняют сам подход к такой работе, в сравнении с процедурным программированием.</p>

<p>Циклы и доступ к элементам коллекции по индексам &mdash; это операции низкого уровня. Вместо них предлагаются более высокоуровневые операции &mdash; map, filter, fold и др. Это тоже уменьшает возможности для появления ошибок.</p>

<p>HOF так же активно проникают из ФП в мейнстримовые языки.</p>


<h3>Static Type-Checking</h3>

<p>Статическая типизация &mdash; это то, что отличает ML от LISP. Большинство ML языков имеют статическую типизацию, а все LISP языки динамически типизированы.</p>

<p>Останавливаться на преимуществах и недостатках того и другого сейчас не будем.</p>


<h3>Automatic Type Inference</h3>

<p>Автоматический вывод типов &mdash; важное дополнение к статической типизации, которое сильно упрощает жизнь программисту. Нет необходимости везде и всюду явно указывать типы, так как во многих случаях компилятор может сам вывести нужный тип.</p>

<p>Это еще одна концепция, которая востребована в мейнстримовых языках.</p>


<h3>Algebraic Data Types</h3>

<p>Алгебраические типы данных &mdash; основной способ моделирования данных. Простой и гибкий, как и все в ФП. Простой, в сравнении с ООП, конечно.</p>

<p>Мейнстримовые языки не особо стремятся это заимствовать. Во-первых, там уже есть ООП, и еще одна штука сбоку просто не нужна. Во-вторых, сами по себе ADT, без Pattern Matching, не так полезны.</p>


<h3>Pattern Matching</h3>

<p>Киллер-фича ФП. Реализует разбор сложных структур данных на составные части и условные переходы. Обычно делает и то, и другое одновременно, что дает лаконичный и выразительный код.</p>

<p>К сожалению, в мейнстримовые языки проникает с трудом и в урезаном виде.</p>


<h3>Parametric Polymorphism</h3>

<p>Достигается во многом за счет описаных выше фич: HOF, ADT и PM.</p>

<p>В языке, который я выберу, мне нужны все эти фичи. Поэтому меня не тянет в мейнстримовые языки. Immutable Programming и High Order Function туда проникли, Static Type Checking и Automatic Type Inference там и так были, а вот с Algebraic Data Type и Pattern Matching дела обстоят неважно. Обойтись без ADT и PM я, конечно, могу. Но зачем? Отказаться от удобных фич, чтобы что?</p>


<h2>Что у меня есть сейчас</h2>

<p><b>Erlang</b> хорош. Простой, не дает мощных абстракций, а просто делают свою работу.</p>

<p>Да, это ML язык. Но при том, что он поддерживает многие фичи ML, на самом деле Erlang не про ML, и вообще не про ФП. Не про моделирование сложных данных, и не про композиции операций над данными.</p>

<p>Erlang про то, чтобы эффективно направить потоки данных откуда-то куда-то. Это язык водопроводчиков, он про трубы и бассейны, как в школьных задачах: сюда затекает столько-то, отсюда вытекает столько-то, смотри, чтобы бассейн не переполнился. Вернее, у тебя десятки бассейнов и сотни труб, разложены на пять нод (а у кого-то на 50, или на 500 нод). Но суть та же &mdash; все должно быстро течь, не засоряться, и не переполняться.</p>

<p>Это нишевый язык под узкие задачи.</p>

<p>Все это интересно, и я с удовольствием занимаюсь этим уже лет 7. Но когда-нибудь мне надоест быть водопроводчиком :) Еще через 7 лет Erlang вряд ли будет моим основным языком.</p>

<p><b>Elixir</b> лучше и мощнее. Это, очевидно, большой шаг вперед. Много фич, которые действительно улучшают жизнь разработчику, в сравнении с аскетичным Erlang.</p>

<p>Но кое-что мне не нравится. Да, формально Elixir является ФП языком и имеет фичи ML языков. Но авторы языка сделали все как-то не так.</p>

<p>Во-первых, потому, что авторам чужды дух и эстетика ML. (Операции с коллекциями в модуле Enum? Серьезно? Enum -- это не коллекция. Оператор pipe подставляет первый аргумент, а не последний? Да, я понимаю, что авторы не осилили каррирование, но они и не хотели).</p>

<p>Во-вторых, потому, что лучше сделать авторы не могли из-за ограничений своего дизайна. Очевидно, что дизайн языка не был продуман изначально, а сформировался случайным образом.</p>

<p>Сфера применения Elixir шире. Но я не уверен, что его можно считать языком общего назначения. Все-таки, это тоже специализированый язык под конкретные области применения.</p>

<p>Еще у меня есть <b>Python</b> &mdash; самый, что ни на есть, мейнстрим. Стабильно в десятке популярных языков по различным рейтингам. Область применения широчайшая. Годится для чего угодно, от мелких скриптов до масштабных проектов.</p>

<p>Однако, мое примерение Python, это больше про мелкие скрипты, чем про масштабные проекты :) Тут задеплоить, тут автоматизировать, тут данные переложить из одной БД в другую. По-мелочи он постоянно нужен, но ничего большого и серьезного я на нем не писал.</p>

<p>Стоит, конечно, изучить язык поглубже. Однако, полноценным Python-разработчиком я быть не хочу. Кажется, что это шаг назад. (Но своего сына я буду учить в первую очередь Python).</p>


<h2>На чем я буду писать завтра?</h2>

<p>Rust имеет все фичи, присущие семейству ML. Вот всё, что выше перечислено &mdash; всё есть. Именно поэтому я обратил внимание на Rust, а не из-за его основных фишек, через которые он рекламируется и продвигается (безопасная работа с памятью и эффективность).</p>

<p>Я попробовал и убедился, что типичный ML код, с ADT, PM, мапами и свертками нормально пишется и вполне канонично выглядит. Да, там move, borrow и lifetime добавляют трудностей. Но трудностей то мы не боимся, если есть ради чего стараться :)</p>

<p>Rust объединяет два мира: ФП программирование и системное программирование.</p>

<p>Где-то рядом с нами, программистами, избалованными GC, обитают суровые мужыки, пишущие код на суровом C и суровом C++. Они знают тайны устройства памяти, управляются с указателями, и умеют писать максимально эффективный код, выжимающий всю возможную производительность из железа.</p>

<p>Я всегда им завидовал. Я прочитал Кернигана и Ричи, прошел 3 курса по C++ на stepic.org, и тоже что-то понял про память и указатели. А еще я понял, что совсем не хочу писать на C++. Зато вот есть Rust, с которым тоже можно погрузиться в этот мир. Вряд ли я буду писать ядро ОС, драйвер сети или базу данных, но и в прикладном программировании эффективный код не лишний.</p>

<p>Итого, два мира в одном языке:
<ul>
<li>ФП, такое, как я люблю;</li>
<li>и системное программирование, такое, которому я всегда завидовал.</li>
</ul></p>

<p>Стоит попробовать :)</p>


<h2>Ссылки</h2>

<p><ul>
<li>Самая лучшая книга по ФП (не важно, что там F#):<br/>
<a href="https://pragprog.com/book/swdddf/domain-modeling-made-functional">Domain Modeling Made Functional. Tackle Software Complexity with Domain-Driven Design and F# by Scott Wlaschin</a></li>
<li><a href="https://www.youtube.com/watch?v=A3AdN7U24iU">Rust: A Language for the Next 40 Years - Carol Nichols</a></li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language by Steve Klabnik and Carol Nichols, with contributions from the Rust Community</a></li>
</ul></p>

<div id="disqus_thread"></div>
<script type="text/javascript">
var disqus_shortname = 'yzh44yzh';

(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</div>
</body>
</html>
